
<aside>
💡 DBMS (=Database Management System)

</aside>

- 데이터베이스를 관리하기 위한 소프트웨어

<aside>
💡 RDBMS (=Relational DBMS)

</aside>

- 관계형 모델(=테이블) 기반으로 하는 DBMS
- 기본키를 통한 행 식별

<aside>
💡 H2

</aside>

- 자바로 작성된 RDBMS
- 스프링 부트가 지원하는 인메모리 관계형 데이터베이스
- 애플리케이션 외부에 저장하지 않고 스프링 부트 애플리케이션 자체 내부에 저장하기에 재실행 할 때마다 초기화
- 개발 시에 테스트 용도로 사용

<aside>
💡 테이블

</aside>

- 행과 열로 구성된 데이터를 구성하기 위한 가장 기본적인 단위

<aside>
💡 행

</aside>

- 테이블의 가로로 배열된 데이터의 집합
- 반드시 고유한 식별자인 기본키를 가진다

<aside>
💡 열

</aside>

- 행에 저장되는 유형의 데이터
- 각 요소에 대한 속성을 나타내며 무결성을 보장

<aside>
💡 기본키 (PK == Primary Key)

</aside>

- 행을 구분할 수 있는 식별자
- Not Null
- 수정되어서는 안되는 값

<aside>
💡 쿼리

</aside>

- SQL이라는 데이터베이스 전용 언어를 사용하여 작성
- 데이터 생성, 조회, 수정, 삭제 작업 처리를 위한 명령문

<aside>
💡 ORM (=Object Relational Mapping)

</aside>

- 객체와 데이터베이스를 연결하는 프로그래밍 기법
- 데이터베이스의 값을 마치 객체처럼 사용할 수 있게 해준다
- 객체와 데이터베이스를 연결해 프로그래밍 언어만으로도 데이터베이스를 다룰 수 있게 하는 도구

> 장점
1. SQL을 직접 작성할 필요 X
2. 객체지향적으로 코드 작성 가능 → 비즈니스 로직에 집중 가능
3. 데이터베이스 시스템이 추상화 → 데이터베이스 시스템에 대한 종속성이 ↓
4. 매핑하는 정보가 명확 → ERD에 대한 의존도 ↓, 유지 보수 유리
> 

> 단점
1. 프로젝트 복잡성이 커질수록 난이도 증가
2. 복잡하고 무거운 쿼리는 ORM으로 불가능한 경우도 존재
> 

<aside>
💡 JPA (=Java Persistence API)

</aside>

- 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
- 인터페이스라서 구현이 필요하다
- 보통은 구현된 프레임워크를 사용한다

<aside>
💡 하이버네이트 (=Hibernate)

</aside>

- JPA 인터페이스를 구현한 구현체
- 자바용 ORM 프레임워크
- 내부적으로는 JDBC API를 사용

<aside>
💡 엔티티 (=Entity)

</aside>

- 데이터베이스의 테이블과 매핑되는 객체
- 그냥 자바 객체이지만 테이블과 연결된다는 특징이 있어 따로 구분
- 객체이긴 하지만 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체
- 엔티티는 반드시 기본 생성자가 있어야 한다 (public or protected)

<aside>
💡 엔티티 매니저 (=Entity Manager)

</aside>

- 엔티티를 관리
- 데이터베이스와 애플리케이션 사이에서 객체를 생성, 수정, 삭제 등을 하는 역할
- 엔티티 매니저는 엔티티 매니저 팩토리에서 만들어진다

> 스프링 부트는 엔티티 매니저 팩토리를 하나 생성
엔티티 매니저는 Spring Data JPA에서 관리 → 직접 관리할 필요 X
> 

<aside>
💡 영속성 컨텍스트

</aside>

- 엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다
- 엔티티를 관리하는 가상의 공간
- 데이터베이스에서 데이터를 효과적으로 가져올 수 있게 한다
- 엔티티를 편하게 사용할 수 있게 한다

> 1차 캐시
> 
- 영속성 컨텍스트는 내부에 1차 캐시를 지닌다
- 캐시의 key : 엔티티의 @Id 애너테이션이 달린 식별자
- 캐시의 value : 엔티티
- 엔티티를 조회 → 1차 캐시에 있는지 조회, 있다면 반환, 없다면 데이터베이스 조회 후 캐시에 저장 후 반환
- 캐시를 통해 데이터베이스를 거치지 않고 바로 반환하는 경우도 있어서 빠르게 조회 가능

> 쓰기 지연 (Transactional write-behind)
> 
- 트랜잭션을 커밋하기 전까지는 데이터베이스에 실제 쿼리문을 보내지 않는다
- 트랜잭션을 커밋하기 전까지의 쿼리들을 모았다가 한 번에 실행하는 행위를 의미
- 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담을 줄일 수 있다

> 변경 감지
> 
- 트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과
    
    현재 엔티티의 값을 비교해서 변경된 값이 있다면
    
    변경 사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영(업데이트)한다
    
- 적당한 묶음으로 쿼리를 요청할 수 있고 데이터베이스 시스템의 부담을 줄일 수 있다

> 지연 로딩 (Lazy loading)
> 
- 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하지 않는다
- 필요할 때 쿼리를 날려 데이터를 조회하는 행위를 의미
- 반대 개념으로 즉시 로딩이 있다
    - 조회할 때 쿼리를 보내 연관된 모든 데이터를 가져오는 행위를 의미

공통점 : 데이터베이스의 접근을 최소화하여 부담을 줄인다(성능을 높인다)

<aside>
💡 엔티티의 4가지 상태

</aside>

1. 비영속 상태
    - 영속성 컨텍스트와 전혀 관계가 없는 상태
    - 엔티티를 처음 만든 상태
    
2. 관리 상태
    - 영속성 컨텍스트가 관리하는 상태
    - persist() 메서드
    
3. 분리 상태
    - 영속성 컨텍스트가 관리하지 않는 상태
    - detach() 메서드
    
4. 삭제된 상태
    - 영속성 컨텍스트와 데이터베이스에서 삭제
    - remove() 메서드

<aside>
💡 스프링 데이터 (=Spring Data)

</aside>

- 데이터베이스 사용 기능을 클래스 레벨에서 추상화하여 비즈니스 로직에 더 집중할 수 있게 한다

<aside>
💡 스프링 데이터 JPA (=Spring Data JPA)

</aside>

- JpaRepository ← PagingAndSortingRepository
- JpaRepository<Entity Name, Entity PK type>
- JPA를 쓰기 편하게 만들어놓은 모듈

<aside>
💡 @GeneratedValue

</aside>

- AUTO (default) : 선택한 데이터베이스 방언에 따라 방식을 자동으로 선택
- IDENTITY : 기본키 생성을 데이터베이스에 위임 (= AUTO_INCREMENT)
- SEQUENCE : 데이터베이스 시퀀스를 사용해 기본키를 할당하는 방법 (오라클에서 주로 사용)
- TABLE : 키 생성 테이블 사용
